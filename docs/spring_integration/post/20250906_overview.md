# Spring Integration
## [Overview](https://docs.spring.io/spring-integration/reference/overview.html)

### Spring Integration 프레임워크 개요
Spring Integration은 잘 알려진 **엔터프라이즈 통합 패턴(Enterprise Integration Patterns)**을 지원하기 위해 Spring 프로그래밍 모델을 확장한 것입니다. 이를 통해 Spring 기반 애플리케이션 내에서 경량 메시징을 가능하게 하며, 선언적 어댑터를 통해 외부 시스템과의 통합을 지원합니다. 이러한 어댑터는 Spring의 원격 호출(remoting), 메시징, 스케줄링 지원을 기반으로 한 상위 수준의 추상화를 제공합니다.

Spring Integration의 주요 목표는 기업 통합 솔루션을 구축하기 위한 간단한 모델을 제공하면서, 유지보수 가능하고 테스트 가능한 코드를 작성하는 데 필수적인 **관심사의 분리(separation of concerns)**를 유지하는 것입니다.

### Spring Integration 개요
이 장에서는 Spring Integration의 핵심 개념과 구성 요소에 대한 고수준 소개를 제공합니다. 또한 Spring Integration을 최대한 효율적으로 활용할 수 있는 프로그래밍 팁도 포함되어 있습니다.

### 배경
Spring Framework의 핵심 주제 중 하나는 **제어의 역전(Inversion of Control, IoC)**입니다. 넓은 의미에서 이는 프레임워크가 관리되는 컴포넌트를 대신하여 여러 책임을 처리한다는 것을 의미합니다. 컴포넌트 자체는 이러한 책임에서 해방되므로 단순해집니다.

예를 들어, **의존성 주입(Dependency Injection)**은 컴포넌트가 자신의 의존성을 찾거나 생성하는 책임에서 해방시킵니다. 마찬가지로 **관점 지향 프로그래밍(AOP)**은 비즈니스 컴포넌트에서 공통적으로 발생하는 관심사를 모듈화된 재사용 가능한 Aspect로 분리하여 처리합니다. 이 모든 과정에서 최종 결과는 테스트하기 쉽고, 이해하기 쉽고, 유지보수 및 확장이 쉬운 시스템이 됩니다.

또한 Spring 프레임워크와 관련 포트폴리오는 엔터프라이즈 애플리케이션을 구축하기 위한 포괄적인 프로그래밍 모델을 제공합니다. 개발자는 인터페이스 기반 프로그래밍, 상속보다 합성(composition) 선호와 같은 확립된 모범 사례를 기반으로 한 일관성 있는 모델의 혜택을 누릴 수 있습니다. Spring의 단순화된 추상화와 강력한 지원 라이브러리는 개발 생산성을 높이는 동시에 테스트 용이성과 이식성을 향상시킵니다.

Spring Integration은 이러한 목표와 원칙에 따라 개발되었습니다. Spring 프로그래밍 모델을 메시징 도메인으로 확장하고, 기존의 Spring 엔터프라이즈 통합 지원을 기반으로 더 높은 수준의 추상화를 제공합니다.

Spring Integration은 **메시지 기반 아키텍처(Message-driven architecture)**를 지원하며, 특정 비즈니스 로직이 언제 실행되고 어디로 응답이 전송될지와 같은 런타임 책임(runtime concerns)에 IoC 개념을 적용합니다. 또한 메시지의 **라우팅(routing)**과 **변환(transformation)**을 지원하여, 서로 다른 전송 방식과 데이터 포맷을 테스트 가능성에 영향을 주지 않고 통합할 수 있습니다. 즉, 메시징 및 통합 관련 책임은 프레임워크가 처리하고, 비즈니스 컴포넌트는 인프라로부터 더욱 분리되며, 개발자는 복잡한 통합 책임에서 해방됩니다.

Spring Integration은 Spring 프로그래밍 모델의 확장으로서 다양한 구성 옵션을 제공합니다. 여기에는 어노테이션, 네임스페이스 지원 XML, 일반 “bean” 요소 기반 XML, 그리고 API 직접 사용 등이 포함됩니다. 이 API는 **잘 정의된 전략 인터페이스(strategy interfaces)**와 비침습적(non-invasive) 위임(delegate) 어댑터를 기반으로 합니다.

Spring Integration의 설계는 Spring 내에서 흔히 발견되는 패턴과, Gregor Hohpe와 Bobby Woolf가 저술한 Enterprise Integration Patterns(Addison Wesley, 2004)에서 설명된 패턴 간의 강한 친화성을 인식하고 영감을 받아 이루어졌습니다. 따라서 이 책을 읽은 개발자는 Spring Integration의 개념과 용어를 바로 이해할 수 있을 것입니다.

### 목표 및 원칙
Spring Integration은 다음과 같은 목표를 가지고 있습니다:
- 복잡한 엔터프라이즈 통합 솔루션을 구현하기 위한 간단한 모델 제공
- Spring 기반 애플리케이션 내에서 비동기 메시지 기반 동작 지원
- 기존 Spring 사용자들이 직관적이고 점진적으로 도입할 수 있도록 촉진

Spring Integration은 다음과 같은 원칙에 따라 설계됩니다:
- 컴포넌트는 모듈화와 테스트 용이성을 위해 느슨하게 결합(loose coupling) 되어야 함
- 프레임워크는 비즈니스 로직과 통합 로직 간의 관심사 분리를 강제해야 함
- 확장 지점(extension points)은 재사용성과 이식성을 촉진하기 위해 추상적이어야 하며, 잘 정의된 경계 내에서 이루어져야 함

### 주요 구성 요소
수직적 관점(vertical perspective)에서 **계층형 아키텍처(layered architecture)**는 관심사의 분리를 촉진하며, 계층 간 **인터페이스 기반 계약(interface-based contract)**은 느슨한 결합을 지원합니다. Spring 기반 애플리케이션은 일반적으로 이러한 방식으로 설계되며, Spring 프레임워크와 관련 포트폴리오는 엔터프라이즈 애플리케이션 전체 스택에서 이 최선의 관행을 따르는 강력한 기반을 제공합니다.

메시지 기반 아키텍처는 수평적 관점(horizontal perspective)을 추가하지만, 이러한 목표는 여전히 유효합니다. “계층형 아키텍처”가 매우 일반적이고 추상적인 패러다임인 것처럼, 메시징 시스템 또한 **파이프-앤-필터(pipes-and-filters)**라는 유사하게 추상적인 모델을 따릅니다. 여기서 “필터(filters)”는 메시지를 생성하거나 소비할 수 있는 모든 컴포넌트를 의미하며, “파이프(pipes)”는 필터 간 메시지를 전달하여 컴포넌트 자체가 느슨하게 결합되도록 합니다.

이 두 가지 상위 수준 패러다임이 서로 배타적이지 않다는 점이 중요합니다. “파이프”를 지원하는 기본 메시징 인프라는 여전히 인터페이스로 정의된 계약을 가진 계층 안에 캡슐화되어야 합니다. 마찬가지로 “필터” 자체도 애플리케이션의 서비스 계층 위에 논리적으로 위치한 계층에서 관리되어야 하며, 웹 계층이 서비스를 인터페이스를 통해 호출하는 방식과 유사하게 서비스와 상호작용해야 합니다.

### 메시지(Message)
Spring Integration에서 메시지는 Java 객체를 일반화하여 감싸고, 프레임워크가 해당 객체를 처리할 때 사용하는 메타데이터와 결합한 구조입니다. 메시지는 **페이로드(payload)**와 **헤더(headers)**로 구성됩니다.
- 페이로드(payload): 메시지의 실제 데이터로, 어떤 타입도 될 수 있습니다.
- 헤더(headers): ID, 타임스탬프, 상관관계 ID(correlation ID), 반환 주소(return address) 등 일반적으로 필요한 정보를 담습니다. 헤더는 연결된 전송(transport)과 데이터를 주고받는 데에도 사용됩니다.

예를 들어, 수신된 파일로 메시지를 생성할 때 파일 이름을 헤더에 저장하여 이후 처리 단계에서 접근할 수 있습니다. 또 다른 예로, 메시지 내용이 최종적으로 아웃바운드 메일 어댑터를 통해 전송될 경우, 수신자(to), 발신자(from), 참조(cc), 제목(subject) 등 다양한 속성이 상류(upstream) 컴포넌트에 의해 메시지 헤더 값으로 설정될 수 있습니다. 개발자는 헤더에 임의의 키-값 쌍을 저장할 수도 있습니다.

### 메시지 채널(Message Channel)
메시지 채널은 파이프-앤-필터(pipes-and-filters) 아키텍처에서 “파이프” 역할을 합니다.
- 생산자(producer)는 메시지를 채널로 보냅니다.
- 소비자(consumer)는 채널에서 메시지를 수신합니다.

메시지 채널은 메시징 컴포넌트 간의 결합도를 낮추고, **메시지 가로채기(interception)**나 모니터링을 위한 편리한 지점을 제공합니다.
메시지 채널은 포인트-투-포인트(point-to-point) 또는 퍼블리시-서브스크라이브(publish-subscribe) 방식 중 하나를 따릅니다.
- 포인트-투-포인트 채널: 한 메시지는 최대 한 명의 소비자에게만 전달됩니다.
- 퍼블리시-서브스크라이브 채널: 메시지는 채널의 모든 구독자에게 방송됩니다.

또한 중요한 고려 사항으로 채널이 메시지를 버퍼링해야 하는지 여부가 있습니다.
- 폴러블(pollable) 채널: 내부 큐에 메시지를 버퍼링할 수 있습니다. 버퍼링의 장점은 인바운드 메시지의 흐름을 조절(throttling)하여 소비자의 과부하를 방지할 수 있다는 점입니다. 단점은 소비자가 메시지를 받으려면 **폴러(poller)**가 구성되어 있어야 한다는 점입니다.
- 서브스크라이버블(subscribable) 채널: 소비자는 단순히 메시지 기반으로 동작하며 폴링이 필요하지 않습니다.

Spring Integration에서 제공하는 다양한 채널 구현에 대한 자세한 내용은 Message Channel Implementations에서 확인할 수 있습니다.

### 메시지 엔드포인트(Message Endpoint)
Spring Integration의 주요 목표 중 하나는 <a id="b_ioc"></a>[제어의 역전(Inversion of Control, IoC)](#ioc)을 통해 엔터프라이즈 통합 솔루션 개발을 단순화하는 것입니다.
즉, 소비자와 생산자를 직접 구현하거나, 메시지를 직접 생성하고 전송(send) 혹은 수신(receive) 연산을 수행할 필요가 없습니다.
대신, 일반 객체(plain objects)를 기반으로 특정 도메인 모델에 집중할 수 있어야 합니다.
선언적 구성(declarative configuration)을 제공함으로써, 도메인 특화 코드를 Spring Integration의 메시징 인프라와 연결할 수 있습니다.
이러한 연결을 담당하는 컴포넌트가 메시지 엔드포인트입니다.
기존 애플리케이션 코드를 직접 연결해야 한다는 의미는 아닙니다. 실제 엔터프라이즈 통합 솔루션에서는 라우팅(routing)이나 변환(transformation) 등 통합 관련 코드가 일정 부분 필요합니다.
중요한 점은 통합 로직과 비즈니스 로직의 관심사 분리를 달성하는 것입니다.
웹 애플리케이션의 MVC(Model-View-Controller) 패러다임처럼, 인바운드 요청을 서비스 계층 호출로 변환하고, 서비스 계층의 반환값을 아웃바운드 응답으로 변환하는 **얇지만 전용 계층(thin dedicated layer)**을 제공하는 것이 목표입니다.
다음 섹션에서는 이러한 책임을 처리하는 메시지 엔드포인트 유형을 개요하고, 이후 장에서는 Spring Integration의 선언적 구성 옵션을 통해 각 엔드포인트를 비침습적(non-invasive) 방식으로 사용하는 방법을 보여줍니다.

#### 메시지 엔드포인트(Message Endpoints)
메시지 엔드포인트는 **파이프-필터(pipes-and-filters) 아키텍처의 “필터”**를 나타냅니다. 앞서 언급했듯이, 엔드포인트의 주요 역할은 애플리케이션 코드를 메시징 프레임워크에 연결하는 것이며, 이 과정에서 애플리케이션 코드가 메시지 객체나 메시지 채널에 대해 알 필요가 없도록 비침습적(non-invasive)으로 연결하는 것입니다. 이는 MVC 패턴에서 컨트롤러의 역할과 유사합니다. 컨트롤러가 HTTP 요청을 처리하는 것처럼, 메시지 엔드포인트는 메시지를 처리합니다. 컨트롤러가 URL 패턴에 매핑되는 것처럼, 메시지 엔드포인트는 메시지 채널에 매핑됩니다. 목표는 두 경우 모두 동일합니다: 애플리케이션 코드를 인프라로부터 분리하는 것입니다. 이러한 개념과 그 이후의 패턴들은 《Enterprise Integration Patterns》 책에서 상세히 다루고 있습니다. 여기서는 Spring Integration에서 지원하는 주요 엔드포인트 유형과 그 역할에 대한 상위 수준의 설명만 제공합니다. 이후 챕터에서는 샘플 코드와 구성 예제를 제공합니다.

#### 메시지 변환기(Message Transformer)
메시지 변환기는 메시지의 내용 또는 구조를 변환하고, 변환된 메시지를 반환하는 역할을 합니다. 가장 일반적인 변환기는 메시지의 payload를 한 형식에서 다른 형식으로 변환하는 경우입니다(예: XML → java.lang.String). 또한 메시지 변환기는 헤더 값을 추가, 삭제, 수정할 수도 있습니다.

#### 메시지 필터(Message Filter)
메시지 필터는 메시지를 출력 채널로 전달할지 여부를 결정합니다. 일반적으로 boolean 테스트 메서드를 사용하며, 특정 payload 타입, 속성 값, 헤더 존재 여부 등 조건을 확인합니다.
메시지가 허용되면 출력 채널로 전달됩니다.
허용되지 않으면 메시지를 삭제하거나(Exception을 던지는 등) 처리합니다.
메시지 필터는 주로 publish-subscribe 채널과 함께 사용됩니다. 여러 소비자가 동일한 메시지를 받지만, 필터 기준을 통해 처리할 메시지를 선별할 수 있습니다.

>주의: 파이프-필터 아키텍처에서의 일반적인 “필터” 개념과, 메시지 엔드포인트로서 메시지를 선별적으로 좁히는 “Message Filter” 유형을 혼동하지 마세요.
>일반적인 파이프-필터 패턴의 “필터”는 Spring Integration의 메시지 엔드포인트와 더 유사합니다. 즉, 메시지를 송수신하기 위해 메시지 채널에 연결될 수 있는 모든 컴포넌트를 의미합니다.

#### 메시지 라우터(Message Router)
메시지 라우터는 메시지를 다음에 어느 채널로 보낼지 결정하는 역할을 합니다. 일반적으로 메시지 내용이나 헤더의 메타데이터를 기반으로 결정합니다.
서비스 액티베이터나 기타 엔드포인트에서 정적으로 구성된 출력 채널을 대신하는 동적 대안으로 사용됩니다.
또한, 앞서 설명한 메시지 필터와 달리, 능동적으로 다수의 구독자에게 메시지를 분배할 수 있습니다.

#### 메시지 분할기(Splitter)
스플리터는 입력 채널에서 메시지를 받아 여러 개의 메시지로 분할하고, 각 메시지를 출력 채널로 보내는 역할을 합니다.
주로 복합(payload) 객체를 여러 메시지로 나누어 처리할 때 사용됩니다.

#### 메시지 집계기(Aggregator)
집계기는 스플리터와 반대로, 여러 메시지를 받아 하나의 메시지로 결합합니다.
일반적으로 파이프라인에서 스플리터의 하류에 위치하며, 여러 메시지를 상태로 유지하고, 모든 메시지가 도착했을 때 결합합니다.
타임아웃 발생 시, 집계 결과를 부분적으로 보내거나 버리거나 별도 채널로 보낼 수도 있습니다.
Spring Integration은 CorrelationStrategy, ReleaseStrategy, 타임아웃 설정, 부분 결과 전송 여부, 폐기 채널 등을 제공합니다.

#### 서비스 액티베이터(Service Activator)
서비스 액티베이터는 서비스 인스턴스를 메시징 시스템에 연결하는 일반적인 엔드포인트입니다.
입력 메시지 채널(input channel)을 구성해야 하며, 서비스 메서드가 값을 반환할 수 있다면 출력 메시지 채널(output channel)도 제공할 수 있습니다.
출력 채널은 선택 사항입니다. 메시지 자체의 ‘Return Address’ 헤더를 사용할 수도 있습니다.
서비스 액티베이터는 서비스 객체의 메서드를 호출하여 요청 메시지를 처리하고, 필요시 reply 메시지를 생성하여 출력 채널로 전달합니다.
요청-응답(service activator) 엔드포인트는 대상 객체의 메서드를 입력 및 출력 메시지 채널에 연결합니다.

#### 채널 어댑터(Channel Adapter)
채널 어댑터는 메시지 채널과 외부 시스템/전송 간의 연결을 담당하는 엔드포인트입니다.
입력 채널 어댑터(inbound)와 출력 채널 어댑터(outbound)가 있습니다.
메시지와 외부 시스템 객체(파일, HTTP 요청, JMS 메시지 등) 간 매핑을 수행합니다.
필요에 따라 메시지 헤더 값을 채우거나 추출할 수도 있습니다.
Spring Integration은 다양한 채널 어댑터를 제공합니다.
- 메시지 소스(inbound adapter): 외부 시스템에서 메시지를 받아 메시지 채널로 전달.
- 메시지 타겟(outbound adapter): 메시지 채널의 메시지를 외부 시스템으로 전송.

채널은 폴링(pollable) 방식 또는 구독(subscribable) 방식으로 동작할 수 있습니다.

#### 엔드포인트 빈 이름(Endpoint Bean Names)
소비자 엔드포인트(입력 채널(inputChannel)을 가진 모든 것)는 두 개의 빈으로 구성됩니다: 하나는 **컨슈머(Consumer)**이고 다른 하나는 **메시지 핸들러(Message Handler)**입니다. 컨슈머는 메시지 핸들러를 참조하고, 메시지가 도착하면 이를 호출합니다.

1. XML 구성 예시:
```
<int:service-activator id="someService" ... />
```
- 컨슈머(Consumer): someService (id)
- 핸들러(Handler): someService.handler

2. EIP 어노테이션 사용 예시:
```
@Component
public class SomeComponent {

    @ServiceActivator(inputChannel = ...)
    public String someMethod(...) {
        ...
    }
}
```
- 컨슈머(Consumer): someComponent.someMethod.serviceActivator
- 핸들러(Handler): someComponent.someMethod.serviceActivator.handler

3. `@EndpointId` 사용 (버전 5.0.4 이상)
```
@Component
public class SomeComponent {

    @EndpointId("someService")
    @ServiceActivator(inputChannel = ...)
    public String someMethod(...) {
        ...
    }
}
```
- 컨슈머(Consumer): someService
- 핸들러(Handler): someService.handler
- `@EndpointId`는 XML 구성에서 id 속성으로 생성된 이름과 동일하게 이름을 만들어줍니다.

4. @Bean 사용 예시
```
@Configuration
public class SomeConfiguration {

    @Bean
    @ServiceActivator(inputChannel = ...)
    public MessageHandler someHandler() {
        ...
    }
}
```
- 컨슈머(Consumer): someConfiguration.someHandler.serviceActivator
- 핸들러(Handler): someHandler (@Bean 이름)

5. @EndpointId 사용
```
@Configuration
public class SomeConfiguration {

    @Bean("someService.handler")             (1)
    @EndpointId("someService")               (2)
    @ServiceActivator(inputChannel = ...)
    public MessageHandler someHandler() {
        ...
    }
}
```
(1) 핸들러(Handler): someService.handler
(2) 컨슈머(Consumer): someService

@EndpointId 어노테이션은 @Bean 이름에 .handler를 붙이는 관례를 사용하는 한, XML 구성에서 id 속성으로 생성된 이름과 동일한 이름을 생성합니다.

하나의 특별한 경우가 있습니다. MessageHandler @Bean이 AbstractReplyProducingMessageHandler를 정의하지 않는 경우, 아키텍처적인 이유로 프레임워크는 해당 빈을 ReplyProducingMessageHandlerWrapper로 감쌉니다.
이 래퍼는 요청 핸들러 어드바이스(request handler advice)를 지원하고, 일반적인 'produced no reply' 디버그 로그 메시지를 출력합니다.
래퍼의 빈 이름은 핸들러 빈 이름 + .wrapper입니다. (@EndpointId가 있는 경우, 그렇지 않으면 일반적으로 생성된 핸들러 이름을 사용)

마찬가지로, **폴링 가능한 메시지 소스(Pollable Message Sources)**는 두 개의 빈을 생성합니다: 
- `SourcePollingChannelAdapter`(SPCA), `MessageSource`

다음 XML 구성을 예로 들어보겠습니다.
```
<int:inbound-channel-adapter id="someAdapter" ... />
```
- SPCA: someAdapter (id)
- 핸들러: someAdapter.source

Java @EndpointId 예시
```
@EndpointId("someAdapter")
@InboundChannelAdapter(channel = "channel3", poller = @Poller(fixedDelay = "5000"))
public String pojoSource() {
    ...
}
```
- SPCA: someAdapter
- 핸들러: someAdapter.source
```
@Bean("someAdapter.source")
@EndpointId("someAdapter")
@InboundChannelAdapter(channel = "channel3", poller = @Poller(fixedDelay = "5000"))
public MessageSource<?> source() {
    return () -> { ... };
}
```
- SPCA: someAdapter
- 핸들러: someAdapter.source (@Bean 이름에 .source를 붙이는 관례 사용)

### 구성(Configuration) 및 @EnableIntegration
이 문서 전반에서 Spring Integration 플로우 내 요소를 선언할 때 XML 네임스페이스 지원에 대한 언급을 볼 수 있습니다. 이 지원은 특정 컴포넌트를 구현하기 위해 적절한 빈 정의를 생성하는 일련의 네임스페이스 파서에 의해 제공됩니다. 예를 들어, 많은 엔드포인트는 MessageHandler 빈과, 해당 핸들러와 입력 채널 이름이 주입되는 ConsumerEndpointFactoryBean으로 구성됩니다.

Spring Integration 네임스페이스 요소가 처음으로 나타날 때, 프레임워크는 런타임 환경을 지원하기 위해 여러 빈(예: 작업 스케줄러, 암묵적 채널 생성기 등)을 자동으로 선언합니다.

버전 4.0에서는 @EnableIntegration 애노테이션이 도입되어 Spring Integration 인프라 빈을 등록할 수 있도록 했습니다. 이 애노테이션은 Java 구성만 사용하는 경우에 필요합니다 — 예를 들어 Spring Boot, Spring Integration Messaging Annotation 지원, 또는 XML 통합 구성이 없는 Spring Integration Java DSL 환경에서 사용됩니다.

또한, @EnableIntegration은 부모 컨텍스트에 Spring Integration 컴포넌트가 없고, Spring Integration을 사용하는 두 개 이상의 하위 컨텍스트가 있을 때 유용합니다. 이 경우 공통 컴포넌트를 부모 컨텍스트에서 한 번만 선언할 수 있습니다.

@EnableIntegration 애노테이션은 애플리케이션 컨텍스트에 다양한 인프라 컴포넌트를 등록합니다. 특히 다음과 같습니다:
- errorChannel과 그 LoggingHandler, 폴러용 taskScheduler, jsonPath SpEL 함수 등 내장 빈 등록
- 글로벌 및 기본 통합 환경을 위한 BeanFactoryPostProcessor 인스턴스 추가
- 통합 목적을 위해 특정 빈을 변환하거나 래핑하는 BeanPostProcessor 인스턴스 추가
- 메시징 애노테이션을 파싱하고 관련 컴포넌트를 애플리케이션 컨텍스트에 등록하는 애노테이션 프로세서 추가

@IntegrationComponentScan 애노테이션은 클래스패스 스캐닝을 허용합니다. 이 애노테이션은 표준 Spring Framework의 @ComponentScan과 유사한 역할을 하지만, 표준 Spring Framework 컴포넌트 스캔 메커니즘이 접근할 수 없는 Spring Integration 전용 컴포넌트와 애노테이션에 제한됩니다. 예로 @MessagingGateway 애노테이션을 참조할 수 있습니다.

@EnablePublisher 애노테이션은 PublisherAnnotationBeanPostProcessor 빈을 등록하고, 채널 속성이 없는 @Publisher 애노테이션에 대해 기본 퍼블리셔 채널(default-publisher-channel)을 구성합니다. 여러 개의 @EnablePublisher 애노테이션이 있는 경우, 모든 기본 채널 값이 동일해야 합니다. 자세한 내용은 @Publisher 애노테이션을 이용한 애노테이션 기반 구성(Annotation-driven Configuration)을 참조하세요.

@GlobalChannelInterceptor 애노테이션은 글로벌 채널 인터셉션을 위해 ChannelInterceptor 빈을 표시하는 데 도입되었습니다. 이 애노테이션은 <int:channel-interceptor> XML 요소의 아날로그 역할을 합니다. @GlobalChannelInterceptor는 클래스 수준(@Component 스테레오타입 애노테이션 포함) 또는 @Configuration 클래스 내 @Bean 메소드에 적용할 수 있으며, 이 경우 빈은 반드시 ChannelInterceptor를 구현해야 합니다.

버전 5.1부터 글로벌 채널 인터셉터는 동적으로 등록된 채널(예: beanFactory.initializeBean()으로 초기화된 빈이나 Java DSL에서 IntegrationFlowContext를 통해 초기화된 빈)에 적용됩니다. 이전에는 애플리케이션 컨텍스트가 갱신된 후 생성된 빈에는 인터셉터가 적용되지 않았습니다.

@IntegrationConverter 애노테이션은 Converter, GenericConverter 또는 ConverterFactory 빈을 integrationConversionService의 후보 변환기로 표시합니다. 이 애노테이션은 <int:converter> XML 요소의 아날로그 역할을 합니다. @IntegrationConverter는 클래스 수준(@Component 스테레오타입 포함)이나 @Configuration 클래스 내 @Bean 메소드에 적용할 수 있습니다.

메시징 애노테이션에 대한 자세한 내용은 Annotation Support를 참조하세요.

### 프로그래밍 고려사항 (Programming Considerations)
Spring Integration의 대부분 클래스는(특별히 언급되지 않는 한) 애플리케이션 컨텍스트에서 빈으로 선언되고 싱글톤이어야 합니다. 이는 해당 클래스의 인스턴스가 스레드 안전(thread-safe)하며, 다른 컴포넌트와의 연결 및 라이프사이클이 Spring의 의존성 주입 컨테이너에 의해 관리됨을 의미합니다.

JacksonJsonUtils, MessageBuilder, ExpressionEvalMap, IntegrationReactiveUtils와 같은 유틸리티 및 빌더 클래스는 Java 코드에서 직접 사용할 수 있습니다. 그러나 Java DSL 팩토리와 IntegrationComponentSpec 구현 결과는 여전히 애플리케이션 컨텍스트에 빈으로 등록해야 합니다.

많은 모듈에서 존재하는 Session 추상화는 스레드 안전하지 않으며, 일반적으로 Factory 패턴 구현을 통해 생성되고 스레드 안전한 Template 패턴을 통해 사용됩니다. 예를 들어 SftpRemoteFileTemplate과 DefaultSftpSessionFactory의 관계를 참고할 수 있습니다.

메시지 처리와 같은 대상 로직에서는 가능하면 POJO(Plain Old Java Object)를 사용하고, 코드에서 프레임워크를 노출하는 경우는 꼭 필요한 경우에만 해야 합니다. 자세한 내용은 **POJO 메소드 호출(POJO Method Invocation)**을 참고하세요.

프레임워크를 클래스에 노출해야 하는 경우, 특히 애플리케이션 시작 시 다음 사항을 고려해야 합니다:
- 컴포넌트가 ApplicationContextAware인 경우, 일반적으로 setApplicationContext() 메소드 내에서 ApplicationContext를 사용하지 마세요. 대신 참조를 저장하고 컨텍스트 라이프사이클 후반부에 사용을 연기해야 합니다.
- 컴포넌트가 InitializingBean을 구현하거나 @PostConstruct 메소드를 사용하는 경우, 이러한 초기화 메소드에서 메시지를 보내지 마세요. 이 시점에서는 애플리케이션 컨텍스트가 아직 초기화되지 않았으므로 메시지 전송이 실패할 가능성이 높습니다.
- 애플리케이션 시작 중 메시지를 보내야 하는 경우, ApplicationListener를 구현하고 ContextRefreshedEvent를 기다립니다.
- 또는 SmartLifecycle을 구현하고, 빈을 늦은 단계(late phase)에 두고 start() 메소드에서 메시지를 보낼 수 있습니다.

### 패키징된 JAR 사용 시 고려사항 (예: Shaded Jars)
Spring Integration은 Spring Framework의 SpringFactories 메커니즘을 사용하여 여러 IntegrationConfigurationInitializer 클래스를 로드함으로써 특정 기능을 부트스트랩합니다. 여기에는 -core JAR뿐만 아니라 -http, -jmx 등 일부 다른 JAR도 포함됩니다. 이 과정에 대한 정보는 각 JAR의 META-INF/spring.factories 파일에 저장됩니다.

일부 개발자는 Apache Maven Shade Plugin과 같은 잘 알려진 도구를 사용하여 애플리케이션과 모든 의존성을 단일 JAR로 재패키징하는 방식을 선호합니다.
기본적으로, Shade Plugin은 Shaded JAR을 생성할 때 spring.factories 파일을 병합하지 않습니다.

sring.factories 외에도 XML 설정을 위해 spring.handlers와 spring.schemas 등의 다른 META-INF 파일도 사용됩니다. 이러한 파일들도 병합되어야 합니다.

Spring Boot의 실행 가능한 JAR 메커니즘은 다른 접근 방식을 취합니다. 실행 가능한 JAR 내에 JAR을 중첩시켜 각 spring.factories 파일이 클래스패스에 그대로 유지되도록 합니다. 따라서 Spring Boot 애플리케이션의 기본 실행 JAR 형식을 사용하는 경우, 추가 작업이 필요하지 않습니다.

Spring Boot를 사용하지 않더라도, Boot에서 제공하는 도구를 활용하여 Shade Plugin을 강화하고 위에서 언급한 파일들을 위한 Transformer를 추가할 수 있습니다. 다음 예제는 해당 플러그인을 구성하는 방법을 보여줍니다.

예제 1. pom.xml
...
    <plugins>
        <plugin>
            <groupId>org.apache.maven.plugins</groupId>
            <artifactId>maven-shade-plugin</artifactId>
            <configuration>
                <keepDependenciesWithProvidedScope>true</keepDependenciesWithProvidedScope>
                <createDependencyReducedPom>true</createDependencyReducedPom>
            </configuration>
            <dependencies>
                <dependency> (1)
                    <groupId>org.springframework.boot</groupId>
                    <artifactId>spring-boot-maven-plugin</artifactId>
                    <version>${spring.boot.version}</version>
                </dependency>
            </dependencies>
            <executions>
                <execution>
                    <phase>package</phase>
                    <goals>
                        <goal>shade</goal>
                    </goals>
                    <configuration>
                        <transformers> (2)
                            <transformer
                                implementation="org.apache.maven.plugins.shade.resource.AppendingTransformer">
                                <resource>META-INF/spring.handlers</resource>
                            </transformer>
                            <transformer
                                implementation="org.springframework.boot.maven.PropertiesMergingResourceTransformer">
                                <resource>META-INF/spring.factories</resource>
                            </transformer>
                            <transformer
                                implementation="org.apache.maven.plugins.shade.resource.AppendingTransformer">
                                <resource>META-INF/spring.schemas</resource>
                            </transformer>
                            <transformer
                                implementation="org.apache.maven.plugins.shade.resource.ServicesResourceTransformer" />
                        </transformers>
                    </configuration>
                </execution>
            </executions>
        </plugin>
    </plugins>
...
구체적으로,
(1) spring-boot-maven-plugin을 의존성으로 추가합니다.
(2) Transformer를 구성합니다.
`${spring.boot.version}` 속성을 추가하거나 명시적인 버전을 사용할 수 있습니다.

### 프로그래밍 팁과 요령
이 섹션에서는 Spring Integration을 최대한 활용할 수 있는 몇 가지 방법을 설명합니다.

#### XML 스키마
XML 구성을 사용할 때, 잘못된 스키마 검증 오류(false schema validation errors)를 피하려면 Spring을 인식하는 IDE를 사용하는 것이 좋습니다. 예를 들어 Spring Tool Suite(STS), Spring IDE 플러그인이 설치된 Eclipse, 또는 IntelliJ IDEA 등이 있습니다. 이러한 IDE는 클래스패스에서 올바른 XML 스키마를 해석할 수 있습니다(META-INF/spring.schemas 파일 사용). STS나 Eclipse 플러그인을 사용할 경우, 프로젝트에서 반드시 Spring Project Nature를 활성화해야 합니다.

특정 레거시 모듈(버전 1.0에 존재했던 모듈)에 대해 인터넷에서 제공되는 스키마는 호환성을 위해 1.0 버전입니다. IDE가 이러한 스키마를 사용할 경우 잘못된 오류가 발생할 수 있습니다.

온라인 스키마에는 다음과 같은 경고가 포함되어 있습니다:
>이 스키마는 Spring Integration Core 1.0 버전을 위한 것입니다. 현재 스키마로 업데이트할 수 없는데, 이는 1.0.3 이하 버전을 사용하는 애플리케이션에 영향을 주기 때문입니다. 이후 버전에서는 "버전 없는(unversioned)" 스키마가 클래스패스에서 해석되며 jar에서 가져옵니다. 자세한 내용은 GitHub를 참고하세요:
>github.com/spring-projects/spring-integration/tree/main/spring-integration-core/src/main/resources/org/springframework/integration/config

영향을 받는 모듈은 다음과 같습니다:
- core (spring-integration.xsd)
- file
- http
- jms
- mail
- security
- stream
- ws
- xml

#### Java 및 DSL 구성용 클래스 이름 찾기
XML 구성과 Spring Integration 네임스페이스 지원을 사용할 경우, XML 파서는 대상 빈(bean)이 어떻게 선언되고 연결되는지를 숨깁니다. 하지만 Java 구성에서는 프레임워크 API를 이해하고, 대상 최종 사용자 애플리케이션에 맞게 활용하는 것이 중요합니다.

EIP 구현의 주요 구성 요소(first-class citizens)는 Message, Channel, Endpoint입니다(이전 장 “Main Components” 참고). 각각의 구현(계약)은 다음과 같습니다:
- org.springframework.messaging.Message: 메시지 관련 내용 참고
- org.springframework.messaging.MessageChannel: 메시지 채널 관련 내용 참고
- org.springframework.integration.endpoint.AbstractEndpoint: Poller 관련 내용 참고

앞의 두 가지는 구현, 구성, 사용 방법이 비교적 간단합니다. 마지막인 AbstractEndpoint는 좀 더 주의가 필요합니다.
AbstractEndpoint는 Spring Framework에서 다양한 컴포넌트 구현에 널리 사용됩니다. 주요 구현체는 다음과 같습니다:
- EventDrivenConsumer: SubscribableChannel에 구독하여 메시지를 수신할 때 사용
- PollingConsumer: PollableChannel에서 메시지를 폴링할 때 사용

메시징 애노테이션이나 Java DSL을 사용할 경우, 이러한 컴포넌트는 신경 쓰지 않아도 됩니다. 프레임워크가 적절한 애노테이션과 BeanPostProcessor 구현으로 자동 생성해주기 때문입니다. 수동으로 컴포넌트를 구성할 때는 ConsumerEndpointFactoryBean을 사용하여 제공된 inputChannel 속성에 기반해 생성할 대상 AbstractEndpoint 소비자 구현을 결정할 수 있습니다.

한편, ConsumerEndpointFactoryBean은 프레임워크 내 또 다른 핵심 구성 요소인 org.springframework.messaging.MessageHandler에 위임합니다. 이 인터페이스의 구현 목적은 엔드포인트가 채널에서 소비한 메시지를 처리하는 것입니다.
Spring Integration의 모든 EIP 구성 요소는 MessageHandler 구현체입니다. 예를 들어: `AggregatingMessageHandler`, `MessageTransformingHandler`, `AbstractMessageSplitter` 등

또한, 대상 프로토콜 아웃바운드 어댑터(예: FileWritingMessageHandler, HttpRequestExecutingMessageHandler, AbstractMqttMessageHandler 등)도 MessageHandler 구현체입니다.

Java 구성을 사용해 Spring Integration 애플리케이션을 개발할 때, 적절한 MessageHandler 구현체를 찾아 @ServiceActivator 설정에 사용할 수 있습니다. 예를 들어 XMPP 메시지를 보내려면(XMPP 지원 참고) 다음과 같이 구성할 수 있습니다.
```
@Bean
@ServiceActivator(inputChannel = "input")
public MessageHandler sendChatMessageHandler(XMPPConnection xmppConnection) {
    ChatMessageSendingMessageHandler handler = new ChatMessageSendingMessageHandler(xmppConnection);

    DefaultXmppHeaderMapper xmppHeaderMapper = new DefaultXmppHeaderMapper();
    xmppHeaderMapper.setRequestHeaderNames("*");
    handler.setHeaderMapper(xmppHeaderMapper);

    return handler;
}
```
MessageHandler 구현체는 메시지 흐름에서 아웃바운드(outbound) 및 처리(processing) 부분을 나타냅니다.
반면, 인바운드(inbound) 메시지 흐름에는 자체적인 컴포넌트가 있으며, 이들은 폴링(polling)과 리스닝(listening) 동작으로 나뉩니다.
리스닝(메시지 드리븐) 컴포넌트는 비교적 단순하며, 일반적으로 메시지를 생성할 준비가 된 단 하나의 타깃 클래스 구현체만 필요합니다.
리스닝 컴포넌트는 다음과 같이 나뉩니다:

단방향 MessageProducerSupport 구현체: AbstractMqttMessageDrivenChannelAdapter, ImapIdleChannelAdapter 등
요청-응답 방식 MessagingGatewaySupport 구현체: AmqpInboundGateway, AbstractWebServiceInboundGateway 등
폴링 기반 인바운드 엔드포인트는 리스너 API를 제공하지 않거나 이러한 동작을 의도하지 않은 프로토콜용입니다. 
예를 들어:
파일 기반 프로토콜(FTP 등)
데이터베이스(RDBMS 또는 NoSQL)
기타
폴링 인바운드 엔드포인트는 두 가지 컴포넌트로 구성됩니다:
폴러(poller) 구성: 주기적으로 폴링 작업을 시작
메시지 소스(Message Source) 클래스: 대상 프로토콜에서 데이터를 읽고, 하류 통합 흐름(downstream integration flow)을 위한 메시지를 생성

폴러 구성의 주요 클래스는 SourcePollingChannelAdapter입니다. 이는 또 다른 AbstractEndpoint 구현체지만, 특히 폴링을 통해 통합 흐름을 시작하는 목적으로 사용됩니다.
메시징 애노테이션이나 Java DSL을 사용할 경우, 일반적으로 이 클래스에 대해 걱정할 필요는 없습니다. 프레임워크가 @InboundChannelAdapter 설정이나 Java DSL 빌더 스펙에 기반해 빈(bean)을 자동 생성해 줍니다.

메시지 소스 컴포넌트는 대상 애플리케이션 개발 측면에서 더 중요하며, 모두 MessageSource 인터페이스를 구현합니다. 예를 들어:
MongoDbMessageSource
AbstractTwitterMessageSource
이를 염두에 두고, JDBC를 사용해 RDBMS 테이블에서 데이터를 읽는 구성(config)은 다음과 유사할 수 있습니다.
```
@Bean
@InboundChannelAdapter(value = "fooChannel", poller = @Poller(fixedDelay="5000"))
public MessageSource<?> storedProc(DataSource dataSource) {
    return new JdbcPollingChannelAdapter(dataSource, "SELECT * FROM foo where status = 0");
}
```
대상 프로토콜용 모든 인바운드 및 아웃바운드 클래스는 해당 Spring Integration 모듈에서 확인할 수 있습니다(대부분의 경우, 해당 패키지 안에 존재). 예를 들어, spring-integration-websocket 어댑터는 다음과 같습니다:
- o.s.i.websocket.inbound.WebSocketInboundChannelAdapter: MessageProducerSupport를 구현하여 소켓에서 프레임을 수신(listen)하고, 메시지를 채널로 생성(produce)합니다.
- o.s.i.websocket.outbound.WebSocketOutboundMessageHandler: 단방향 AbstractMessageHandler 구현체로, 들어오는 메시지를 적절한 프레임으로 변환하여 웹소켓을 통해 전송합니다.

Spring Integration XML 구성을 알고 있다면, 버전 4.3부터 XSD 요소 정의에 어댑터나 게이트웨이용 빈(bean)을 선언하는 데 사용되는 대상 클래스 정보를 제공합니다. 다음 예제와 같이 확인할 수 있습니다.
```
<xsd:element name="outbound-async-gateway">
    <xsd:annotation>
		<xsd:documentation>
Configures a Consumer Endpoint for the 'o.s.i.amqp.outbound.AsyncAmqpOutboundGateway'
that will publish an AMQP Message to the provided Exchange and expect a reply Message.
The sending thread returns immediately; the reply is sent asynchronously; uses 'AsyncRabbitTemplate.sendAndReceive()'.
       </xsd:documentation>
	</xsd:annotation>
```

POJO 메서드 호출
프로그래밍 고려사항 에서 설명한 대로 다음 예와 같이 POJO 프로그래밍 스타일을 사용하는 것이 좋습니다.
```
@ServiceActivator
public String myService(String payload) { ... }
```
이 경우, 프레임워크는 String 타입의 payload를 추출하고, 사용자의 메서드를 호출한 뒤, 결과를 메시지로 래핑하여 플로우의 다음 컴포넌트로 전달합니다. (원래 헤더는 새 메시지에 복사됩니다.) 사실, XML 구성을 사용하는 경우 @ServiceActivator 애노테이션조차 필요하지 않습니다. 다음 예제처럼 XML과 POJO를 조합할 수 있습니다:
```
<int:service-activator ... ref="myPojo" method="myService" />
```
```
public String myService(String payload) { ... }
```
method클래스의 공개 메서드에 모호함이 없는 한 속성을 생략할 수 있습니다.
다음 예제와 같이 POJO 메서드에서 헤더 정보를 얻을 수도 있습니다.
```
@ServiceActivator
public String myService(@Payload String payload, @Header("foo") String fooHeader) { ... }
```
다음 예제와 같이 메시지의 속성을 역참조할 수도 있습니다.
```
@ServiceActivator
public String myService(@Payload("payload.foo") String foo, @Header("bar.baz") String barbaz) { ... }
```
5.0 이전 버전에서는 다양한 POJO 메서드 호출을 위해 SpEL(Spring Expression Language)을 사용했습니다. SpEL(해석 방식 사용 시)도 대부분의 메서드 처리 작업에 비해 충분히 빠른 편입니다. 그러나 5.0부터는 가능할 경우 기본적으로 org.springframework.messaging.handler.invocation.InvocableHandlerMethod가 사용됩니다. 이 방식은 해석된 SpEL보다 실행 속도가 빠르고, 다른 Spring 메시징 프로젝트와 일관성이 있습니다. InvocableHandlerMethod는 Spring MVC에서 컨트롤러 메서드를 호출할 때 사용되는 방식과 유사합니다.

다만, 이전에 논의된 것처럼 프로퍼티 경로를 참조하는 애노테이션 파라미터 등 일부 메서드는 여전히 SpEL을 사용하여 호출됩니다. 그 외 예상치 못한 일부 경우에도 InvocableHandlerMethod가 작동하지 않으면 자동으로 SpEL로 폴백(fallback)됩니다.

원하면 POJO 메서드를 항상 SpEL을 사용하도록 설정할 수도 있습니다. @UseSpelInvoker 애노테이션을 사용하면 됩니다:
```
@UseSpelInvoker(compilerMode = "IMMEDIATE")
public void bar(String bar) { ... }
```
compilerMode 속성을 생략하면, spring.expression.compiler.mode 시스템 속성이 컴파일러 모드를 결정합니다. 컴파일된 SpEL에 대한 자세한 내용은 SpEL 컴파일 관련 문서를 참고하세요.

---
#### **IoC
[돌아가기](#b_ioc)
- 객체 생성과 의존성을 내가 직접 제어하지 않고, 프레임워크가 대신 관리하도록 맡기는 것
- 전통적인 프로그램에서는 내가 필요한 객체를 직접 만들고 관리
```
class B {
    void doSomething() { ... }
}

class A {
    private B b = new B();  // 직접 객체 생성
    void process() {
        b.doSomething();
    }
}
```
- 제어의 흐름을 내가 아닌 외부(프레임워크)가 가져가는 것
```
class B {
    void doSomething() { ... }
}

class A {
    private B b;

    // 생성자 주입(Constructor Injection)
    public A(B b) {
        this.b = b;
    }

    void process() {
        b.doSomething();
    }
}

// Spring이 대신 객체 생성 후 주입
B b = new B();
A a = new A(b);

```