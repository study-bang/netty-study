Spring 통합 프레임워크 개요
Spring Integration은 잘 알려진 엔터프라이즈 통합 패턴(Enterprise Integration Patterns)을 지원하기 위해 Spring 프로그래밍 모델을 확장합니다 . Spring 기반 애플리케이션 내에서 경량 메시징을 지원하고 선언적 어댑터를 통해 외부 시스템과의 통합을 지원합니다. 이러한 어댑터는 Spring의 원격, 메시징 및 스케줄링 지원보다 더 높은 수준의 추상화를 제공합니다.

Spring Integration의 주요 목표는 유지 관리 가능하고 테스트 가능한 코드를 생성하는 데 필수적인 관심사 분리를 유지하면서 엔터프라이즈 통합 솔루션을 구축하기 위한 간단한 모델을 제공하는 것입니다.

Spring 통합 개요
이 장에서는 Spring Integration의 핵심 개념과 구성 요소를 간략하게 소개합니다. Spring Integration을 최대한 활용하는 데 도움이 되는 몇 가지 프로그래밍 팁도 포함되어 있습니다.

배경
Spring 프레임워크의 핵심 주제 중 하나는 제어 역전(IoC)입니다. 넓은 의미에서 이는 프레임워크가 해당 컨텍스트 내에서 관리되는 구성 요소를 대신하여 책임을 처리한다는 것을 의미합니다. 구성 요소 자체는 이러한 책임에서 벗어나 간소화됩니다. 예를 들어, 의존성 주입은 구성 요소가 종속성을 찾거나 생성하는 책임을 덜어줍니다. 마찬가지로, 관점 지향 프로그래밍은 비즈니스 구성 요소를 재사용 가능한 관점으로 모듈화하여 일반적인 횡단 관심사(cross-cutting concern)로부터 해방시켜 줍니다. 각 경우의 최종 결과는 테스트, 이해, 유지 관리 및 확장이 더 쉬운 시스템입니다.

더욱이 Spring 프레임워크와 포트폴리오는 엔터프라이즈 애플리케이션 구축을 위한 포괄적인 프로그래밍 모델을 제공합니다. 개발자는 이 모델의 일관성, 특히 인터페이스 프로그래밍 및 상속보다 구성(composition)을 선호하는 등 잘 확립된 모범 사례를 기반으로 한다는 점에서 이점을 얻습니다. Spring의 간소화된 추상화와 강력한 지원 라이브러리는 개발자 생산성을 높이는 동시에 테스트 용이성과 이식성 수준을 높입니다.

Spring Integration은 이와 동일한 목표와 원칙에서 영감을 받았습니다. Spring 프로그래밍 모델을 메시징 영역으로 확장하고 Spring의 기존 엔터프라이즈 통합 지원을 기반으로 더욱 높은 수준의 추상화를 제공합니다. 특정 비즈니스 로직이 언제 실행되어야 하고 응답이 어디로 전송되어야 하는지와 같은 런타임 문제에 제어 역전이 적용되는 메시지 기반 아키텍처를 지원합니다. 또한, 테스트 용이성에 영향을 주지 않고 다양한 전송 방식과 데이터 형식을 통합할 수 있도록 메시지 라우팅 및 변환을 지원합니다. 즉, 메시징 및 통합 문제는 프레임워크에서 처리됩니다. 비즈니스 구성 요소는 인프라에서 더욱 분리되고 개발자는 복잡한 통합 작업에서 벗어날 수 있습니다.

Spring 프로그래밍 모델의 확장으로서 Spring Integration은 어노테이션, 네임스페이스를 지원하는 XML, 일반 "빈" 요소를 포함하는 XML, 그리고 기본 API 직접 사용 등 다양한 구성 옵션을 제공합니다. 이 API는 명확하게 정의된 전략 인터페이스와 비침투적 위임 어댑터를 기반으로 합니다. Spring Integration의 설계는 Gregor Hohpe와 Bobby Woolf의 저서 Enterprise Integration Patterns (Addison Wesley, 2004)에 설명된 잘 알려진 패턴과 Spring 내의 공통 패턴 간의 강력한 유사성을 인식하여 이루어졌습니다. 이 책을 읽은 개발자라면 Spring Integration의 개념과 용어에 즉시 익숙해질 것입니다.

목표와 원칙
Spring Integration은 다음과 같은 목표를 가지고 있습니다.

복잡한 기업 통합 솔루션을 구현하기 위한 간단한 모델을 제공합니다.

Spring 기반 애플리케이션 내에서 비동기식 메시지 기반 동작을 용이하게 합니다.

기존 Spring 사용자를 대상으로 직관적이고 점진적인 도입을 장려합니다.

Spring Integration은 다음 원칙에 따라 진행됩니다.

구성 요소는 모듈성과 테스트 용이성을 위해 느슨하게 결합되어야 합니다.

프레임워크는 비즈니스 로직과 통합 로직 간의 관심사 분리를 강화해야 합니다.

재사용과 이식성을 촉진하기 위해 확장 지점은 본질적으로 추상적이어야 합니다(그러나 명확하게 정의된 경계 내에서).

주요 구성 요소
수직적 관점에서 계층적 아키텍처는 관심사 분리를 용이하게 하고, 계층 간 인터페이스 기반 계약은 느슨한 결합을 촉진합니다. Spring 기반 애플리케이션은 일반적으로 이러한 방식으로 설계되며, Spring 프레임워크와 포트폴리오는 엔터프라이즈 애플리케이션의 전체 스택에 대해 이러한 모범 사례를 따르기 위한 강력한 기반을 제공합니다. 메시지 기반 아키텍처는 수평적 관점을 더하지만, 동일한 목표는 여전히 유효합니다. "계층적 아키텍처"가 매우 일반적이고 추상적인 패러다임인 것처럼, 메시징 시스템은 일반적으로 유사하게 추상적인 "파이프-필터" 모델을 따릅니다. "필터"는 메시지를 생성하거나 사용할 수 있는 모든 구성 요소를 나타내며, "파이프"는 구성 요소 자체가 느슨한 결합을 유지하도록 필터 간에 메시지를 전송합니다. 이 두 가지 상위 패러다임이 상호 배타적이지 않다는 점에 유의해야 합니다. "파이프"를 지원하는 기본 메시징 인프라는 계약이 인터페이스로 정의된 계층에 캡슐화되어야 합니다. 마찬가지로, "필터" 자체도 애플리케이션의 서비스 계층보다 논리적으로 상위에 있는 계층에서 관리되어야 하며, 웹 계층과 거의 같은 방식으로 인터페이스를 통해 해당 서비스와 상호 작용해야 합니다.

메시지
Spring Integration에서 메시지는 프레임워크에서 해당 객체를 처리하는 데 사용되는 메타데이터와 결합된 모든 Java 객체에 대한 일반 래퍼입니다. 메시지는 페이로드와 헤더로 구성됩니다. 페이로드는 모든 유형이 될 수 있으며, 헤더는 ID, 타임스탬프, 상관 관계 ID, 반환 주소와 같이 일반적으로 필요한 정보를 포함합니다. 헤더는 연결된 전송과 값을 주고받는 데에도 사용됩니다. 예를 들어, 수신된 파일에서 메시지를 생성할 때 파일 이름은 다운스트림 구성 요소에서 액세스할 수 있도록 헤더에 저장될 수 있습니다. 마찬가지로, 메시지의 내용이 아웃바운드 메일 어댑터에서 최종적으로 전송되는 경우, 업스트림 구성 요소에서 다양한 속성(수신자, 발신자, 참조, 제목 등)을 메시지 헤더 값으로 구성할 수 있습니다. 개발자는 헤더에 임의의 키-값 쌍을 저장할 수도 있습니다.

메시지
그림 1. 메시지
메시지 채널
메시지 채널은 파이프-필터 아키텍처의 "파이프"를 나타냅니다. 프로듀서는 채널로 메시지를 보내고, 컨슈머는 채널에서 메시지를 수신합니다. 따라서 메시지 채널은 메시징 구성 요소를 분리하고 메시지를 가로채고 모니터링할 수 있는 편리한 지점을 제공합니다.

메시지 채널
그림 2. 메시지 채널
메시지 채널은 지점 간(point-to-point) 또는 발행-구독(publish-subscribe) 방식을 따를 수 있습니다. 지점 간(point-to-point) 채널에서는 채널로 전송된 각 메시지를 한 명의 소비자만 수신할 수 있습니다. 반면, 발행-구독 채널은 각 메시지를 채널의 모든 구독자에게 브로드캐스트합니다. Spring Integration은 이 두 모델을 모두 지원합니다.

"지점 간"과 "게시-구독"은 각 메시지를 최종적으로 수신하는 소비자 수에 대한 두 가지 옵션을 정의하지만, 또 다른 중요한 고려 사항이 있습니다. 채널이 메시지를 버퍼링해야 할까요? Spring Integration에서 폴링 가능 채널은 큐 내의 메시지를 버퍼링할 수 있습니다. 버퍼링의 장점은 수신 메시지의 양을 조절하여 소비자의 과부하를 방지할 수 있다는 것입니다. 하지만 이름에서 알 수 있듯이, 소비자는 폴러가 구성된 경우에만 해당 채널에서 메시지를 수신할 수 있기 때문에 복잡성이 증가합니다. 반면, 구독 가능 채널에 연결된 소비자는 단순히 메시지 기반입니다. 메시지 채널 구현에서는 Spring Integration에서 사용 가능한 다양한 채널 구현에 대해 자세히 설명합니다.

메시지 엔드포인트
Spring Integration의 주요 목표 중 하나는 제어 역전(Inversion of Control)을 통해 엔터프라이즈 통합 솔루션 개발을 간소화하는 것입니다. 즉, 소비자와 생산자를 직접 구현할 필요가 없고, 메시지 채널을 통해 메시지를 빌드하고 송수신 작업을 호출할 필요도 없습니다. 대신, 일반 객체 기반 구현을 통해 특정 도메인 모델에 집중할 수 있어야 합니다. 그런 다음 선언적 구성을 제공함으로써 도메인별 코드를 Spring Integration에서 제공하는 메시징 인프라에 "연결"할 수 있습니다. 이러한 연결을 담당하는 구성 요소는 메시지 엔드포인트입니다. 이는 기존 애플리케이션 코드를 반드시 직접 연결해야 한다는 것을 의미하지는 않습니다. 모든 실제 엔터프라이즈 통합 솔루션에는 라우팅 및 변환과 같은 통합 문제에 초점을 맞춘 어느 정도의 코드가 필요합니다. 중요한 것은 통합 로직과 비즈니스 로직 간의 문제를 분리하는 것입니다. 다시 말해, 웹 애플리케이션의 모델-뷰-컨트롤러(MVC) 패러다임과 마찬가지로, 인바운드 요청을 서비스 계층 호출로 변환하고 서비스 계층 반환 값을 아웃바운드 응답으로 변환하는 얇지만 전용 계층을 제공하는 것이 목표여야 합니다. 다음 섹션에서는 이러한 책임을 처리하는 메시지 엔드포인트 유형에 대한 개요를 제공하며, 이후 장에서는 Spring Integration의 선언적 구성 옵션이 이러한 각 유형을 사용하는 비침투적 방법을 어떻게 제공하는지 확인할 수 있습니다.

메시지 엔드포인트
메시지 엔드포인트는 파이프-필터 아키텍처의 "필터"를 나타냅니다. 앞서 언급했듯이 엔드포인트의 주요 역할은 애플리케이션 코드를 메시징 프레임워크에 비침투적인 방식으로 연결하는 것입니다. 즉, 애플리케이션 코드는 메시지 객체나 메시지 채널을 인식하지 않는 것이 이상적입니다. 이는 MVC 패러다임에서 컨트롤러의 역할과 유사합니다. 컨트롤러가 HTTP 요청을 처리하는 것처럼 메시지 엔드포인트도 메시지를 처리합니다. 컨트롤러가 URL 패턴에 매핑되는 것처럼 메시지 엔드포인트는 메시지 채널에 매핑됩니다. 두 경우 모두 목표는 동일합니다. 애플리케이션 코드를 인프라에서 분리하는 것입니다. 이러한 개념과 이어지는 모든 패턴은 Enterprise Integration Patterns 책에서 자세히 설명합니다. 여기서는 Spring Integration에서 지원하는 주요 엔드포인트 유형과 해당 유형과 관련된 역할에 대한 간략한 설명만 제공합니다. 다음 장에서는 샘플 코드와 구성 예제를 자세히 설명합니다.

메시지 변환기
메시지 변환기는 메시지의 내용이나 구조를 변환하고 수정된 메시지를 반환합니다. 가장 일반적인 변환기 유형은 메시지의 페이로드를 한 형식에서 다른 형식(예: XML에서 .NET으로 java.lang.String)으로 변환하는 것입니다. 마찬가지로, 변환기는 메시지의 헤더 값을 추가, 제거 또는 수정할 수 있습니다.

메시지 필터
메시지 필터는 메시지를 출력 채널로 전달해야 하는지 여부를 결정합니다. 이를 위해서는 특정 페이로드 콘텐츠 유형, 속성 값, 헤더 존재 여부 또는 기타 조건을 검사하는 부울 테스트 메서드만 필요합니다. 메시지가 승인되면 출력 채널로 전송되고, 승인되지 않으면 삭제됩니다(더 엄격한 구현에서는 를 Exceptionthrow할 수도 있음). 메시지 필터는 종종 발행-구독 채널과 함께 사용되는데, 이 경우 여러 소비자가 동일한 메시지를 수신하고 필터 기준을 사용하여 처리할 메시지 집합을 좁힐 수 있습니다.

파이프-필터 아키텍처 패턴에서 사용되는 "필터"라는 용어를 두 채널 간 메시지 흐름을 선택적으로 제한하는 특정 엔드포인트 유형과 혼동하지 않도록 주의하세요. 파이프-필터에서 사용되는 "필터"라는 용어는 Spring Integration의 메시지 엔드포인트, 즉 메시지를 주고받기 위해 메시지 채널에 연결할 수 있는 모든 컴포넌트와 더욱 밀접하게 연관됩니다.
메시지 라우터
메시지 라우터는 다음에 어떤 채널(있는 경우)이 메시지를 수신할지 결정하는 역할을 합니다. 일반적으로 이러한 결정은 메시지의 내용이나 메시지 헤더에 있는 메타데이터를 기반으로 합니다. 메시지 라우터는 서비스 활성화기 또는 응답 메시지를 전송할 수 있는 다른 엔드포인트에서 정적으로 구성된 출력 채널에 대한 동적 대안으로 자주 사용됩니다. 마찬가지로, 메시지 라우터는 앞서 설명한 것처럼 여러 구독자가 사용하는 반응형 메시지 필터에 대한 능동적인 대안을 제공합니다.

라우터
그림 3. 메시지 라우터
쪼개는 도구
스플리터는 입력 채널에서 메시지를 수신하고, 해당 메시지를 여러 개의 메시지로 분할하여 각 메시지를 출력 채널로 전송하는 역할을 하는 또 다른 유형의 메시지 엔드포인트입니다. 일반적으로 "복합" 페이로드 객체를 분할된 페이로드를 포함하는 메시지 그룹으로 나누는 데 사용됩니다.

애그리게이터
기본적으로 스플리터의 미러 이미지인 애그리게이터는 여러 메시지를 수신하여 단일 메시지로 결합하는 메시지 엔드포인트 유형입니다. 실제로 애그리게이터는 스플리터를 포함하는 파이프라인에서 다운스트림 소비자인 경우가 많습니다. 기술적으로 애그리게이터는 상태(집계할 메시지)를 유지하고, 전체 메시지 그룹을 언제 사용할 수 있는지 결정하고, 필요한 경우 시간 초과를 적용해야 하기 때문에 스플리터보다 더 복잡합니다. 또한, 시간 초과가 발생하면 애그리게이터는 부분 결과를 전송할지, 삭제할지, 또는 별도의 채널로 전송할지 알아야 합니다. Spring Integration은 시간 초과 CorrelationStrategy, ReleaseStrategy시간 초과 시 부분 결과 전송 여부, 그리고 삭제 채널에 대한 구성 가능한 설정, , 를 제공합니다.

서비스 활성화
서비스 활성화기는 서비스 인스턴스를 메시징 시스템에 연결하는 일반적인 엔드포인트입니다. 입력 메시지 채널을 구성해야 하며, 호출할 서비스 메서드가 값을 반환할 수 있는 경우 출력 메시지 채널도 제공할 수 있습니다.

각 메시지는 자체 '반송 주소' 헤더를 제공할 수 있으므로 출력 채널은 선택 사항입니다. 이 규칙은 모든 소비자 엔드포인트에 적용됩니다.
서비스 활성화기는 요청 메시지를 처리하기 위해 특정 서비스 객체에 연산을 호출하고, 요청 메시지의 페이로드를 추출하여 변환합니다(해당 메서드가 메시지 유형 매개변수를 기대하지 않는 경우). 서비스 객체의 메서드가 값을 반환할 때마다, 해당 반환 값은 필요에 따라 응답 메시지로 변환됩니다(아직 메시지 유형이 아닌 경우). 해당 응답 메시지는 출력 채널로 전송됩니다. 출력 채널이 구성되지 않은 경우, 응답은 메시지의 "반송 주소"에 지정된 채널(사용 가능한 경우)로 전송됩니다.

요청-응답 서비스 활성화 엔드포인트는 대상 객체의 메서드를 입력 및 출력 메시지 채널에 연결합니다.

핸들러 엔드포인트
그림 4. 서비스 활성화기
앞서 설명했듯이, 메시지 채널 에서 채널은 폴링(polling) 또는 구독(subscribing)이 가능합니다. 위 그림에서 이는 "시계" 기호와 실선 화살표(폴링) 및 점선 화살표(구독)로 표시되어 있습니다.
채널 어댑터
채널 어댑터는 메시지 채널을 다른 시스템이나 전송 수단에 연결하는 엔드포인트입니다. 채널 어댑터는 인바운드 또는 아웃바운드일 수 있습니다. 일반적으로 채널 어댑터는 메시지와 다른 시스템(파일, HTTP 요청, JMS 메시지 등)에서 수신되거나 전송되는 객체 또는 리소스 간의 매핑을 수행합니다. 전송 수단에 따라 채널 어댑터는 메시지 헤더 값을 채우거나 추출할 수도 있습니다. Spring Integration은 다양한 채널 어댑터를 제공하며, 이에 대해서는 다음 장에서 설명합니다.

소스 엔드포인트
그림 5. 인바운드 채널 어댑터 엔드포인트는 소스 시스템을 MessageChannel.에 연결합니다.
메시지 소스는 폴링 가능(예: POP3) 또는 메시지 기반(예: IMAP Idle)일 수 있습니다. 위 그림에서 이는 "시계" 기호와 실선 화살표(폴링) 및 점선 화살표(메시지 기반)로 표시되어 있습니다.
대상 엔드포인트
그림 6. 아웃바운드 채널 어댑터 엔드포인트는 MessageChannel대상 시스템에 연결합니다.
앞서 메시지 채널 에서 설명했듯이 , 채널은 폴링(polling) 또는 구독(subscribing)이 가능합니다. 앞의 다이어그램에서 이는 "시계" 기호와 실선 화살표(폴링) 및 점선 화살표(구독)로 표시되어 있습니다.
엔드포인트 빈 이름
소비 엔드포인트( 를 포함하는 모든 것 inputChannel)는 소비자와 메시지 핸들러라는 두 개의 빈으로 구성됩니다. 소비자는 메시지 핸들러에 대한 참조를 가지며 메시지가 도착하면 해당 핸들러를 호출합니다.

다음 XML 예를 살펴보세요.

<int:service-activator id = "someService" ... />
앞의 예를 보면, 빈 이름은 다음과 같습니다.

소비자: someService(그 id)

매니저:someService.handler

EIP(Enterprise Integration Pattern) 애노테이션을 사용할 때 이름은 여러 요인에 따라 달라집니다. 다음 애노테이션이 추가된 POJO의 예를 살펴보겠습니다.

@Component
public class SomeComponent {

    @ServiceActivator(inputChannel = ...)
    public String someMethod(...) {
        ...
    }

}
앞의 예를 보면, 빈 이름은 다음과 같습니다.

소비자:someComponent.someMethod.serviceActivator

매니저:someComponent.someMethod.serviceActivator.handler

버전 5.0.4부터 @EndpointId다음 예제와 같이 주석을 사용하여 이러한 이름을 수정할 수 있습니다.

@Component
public class SomeComponent {

    @EndpointId("someService")
    @ServiceActivator(inputChannel = ...)
    public String someMethod(...) {
        ...
    }

}
앞의 예를 보면, 빈 이름은 다음과 같습니다.

소비자:someService

매니저:someService.handler

@EndpointIdXML 구성을 사용하여 속성 에 따라 생성된 이름을 생성합니다 . id다음 주석이 달린 Bean의 예를 살펴보겠습니다.

@Configuration
public class SomeConfiguration {

    @Bean
    @ServiceActivator(inputChannel = ...)
    public MessageHandler someHandler() {
        ...
    }

}
앞의 예를 보면, 빈 이름은 다음과 같습니다.

소비자:someConfiguration.someHandler.serviceActivator

핸들러: someHandler( @Bean이름)

버전 5.0.4부터 @EndpointId다음 예제와 같이 주석을 사용하여 이러한 이름을 수정할 수 있습니다.

@Configuration
public class SomeConfiguration {

    @Bean("someService.handler")             
    @EndpointId("someService")               
    @ServiceActivator(inputChannel = ...)
    public MessageHandler someHandler() {
        ...
    }

}
핸들러: someService.handler(빈 이름)
소비자: someService(엔드포인트 ID)
주석은 XML 구성을 사용하여 속성 @EndpointId에 의해 생성된 이름을 생성합니다 id. 단, 이름 .handler에 추가하는 규칙을 사용해야 합니다 @Bean.

세 번째 빈이 생성되는 특별한 경우가 하나 있습니다. 아키텍처상의 이유로, a가 MessageHandler @Beanan을 정의하지 않으면 AbstractReplyProducingMessageHandler프레임워크는 제공된 빈을 a로 래핑합니다 ReplyProducingMessageHandlerWrapper. 이 래퍼는 요청 핸들러 어드바이스 처리를 지원하고 일반적인 'produced no reply' 디버그 로그 메시지를 생성합니다. 빈 이름은 핸들러 빈 이름에 .wrapper(-가 있는 경우 @EndpointId , 그렇지 않은 경우 일반적으로 생성된 핸들러 이름)을 더한 값입니다.

마찬가지로, 폴링 가능 메시지 소스는SourcePollingChannelAdapter (SPCA)와 MessageSource. 라는 두 개의 빈을 생성합니다 .

다음 XML 구성을 고려하세요.

<int:inbound-channel-adapter id = "someAdapter" ... />
앞의 XML 구성을 고려하면 빈 이름은 다음과 같습니다.

SPCA: someAdapter(그 id)

매니저:someAdapter.source

POJO를 정의하기 위한 다음 Java 구성을 고려해 보세요 @EndpointId.

@EndpointId("someAdapter")
@InboundChannelAdapter(channel = "channel3", poller = @Poller(fixedDelay = "5000"))
public String pojoSource() {
    ...
}
앞의 Java 구성 예제에서 빈 이름은 다음과 같습니다.

SPCA:someAdapter

매니저:someAdapter.source

빈을 정의하기 위한 다음의 Java 구성을 고려해 보세요 @EndpointID.

@Bean("someAdapter.source")
@EndpointId("someAdapter")
@InboundChannelAdapter(channel = "channel3", poller = @Poller(fixedDelay = "5000"))
public MessageSource<?> source() {
    return () -> {
        ...
    };
}
앞의 예를 보면, 빈 이름은 다음과 같습니다.

SPCA:someAdapter

핸들러: (이름 에 someAdapter.source추가하는 규칙을 사용하는 경우 ).source@Bean

구성 및@EnableIntegration
이 문서 전체에서 Spring Integration 플로우에서 요소를 선언하기 위한 XML 네임스페이스 지원에 대한 참조를 볼 수 있습니다. 이러한 지원은 특정 컴포넌트를 구현하는 데 적합한 빈 정의를 생성하는 일련의 네임스페이스 파서를 통해 제공됩니다. 예를 들어, 많은 엔드포인트는 MessageHandler빈과 ConsumerEndpointFactoryBean핸들러와 입력 채널 이름이 주입되는 로 구성됩니다.

Spring Integration 네임스페이스 요소가 처음 발견되면 프레임워크는 런타임 환경을 지원하는 데 사용되는 여러 개의 빈(작업 스케줄러, 암묵적 채널 생성자 등)을 자동으로 선언합니다.

버전 4.0에서는 @EnableIntegrationSpring Integration 인프라 빈 등록을 허용하는 애노테이션이 도입되었습니다( Javadoc 참조 ). 이 애노테이션은 Java 구성만 사용하는 경우(예: Spring Boot 또는 Spring Integration 메시징 애노테이션을 지원하고 XML 통합 구성 없이 Spring Integration Java DSL을 사용하는 경우)에 필요합니다.
이 @EnableIntegration애노테이션은 Spring Integration 컴포넌트가 없는 부모 컨텍스트와 Spring Integration을 사용하는 두 개 이상의 자식 컨텍스트가 있는 경우에도 유용합니다. 이러한 공통 컴포넌트를 부모 컨텍스트에서 한 번만 선언할 수 있습니다.

이 @EnableIntegration주석은 여러 인프라 구성 요소를 애플리케이션 컨텍스트에 등록합니다. 특히 다음과 같은 기능을 제공합니다.

폴러, SpEL 함수 등을 위해 errorChannel및 와 LoggingHandler같은 일부 내장 빈을 등록합니다 .taskSchedulerjsonPath

글로벌 및 기본 통합 환경을 BeanFactoryPostProcessor향상시키기 위해 여러 인스턴스를 추가합니다 .BeanFactory

BeanPostProcessor통합 목적으로 특정 빈을 향상시키거나 변환하고 래핑하기 위해 여러 인스턴스를 추가합니다 .

메시징 주석을 구문 분석하고 해당 주석에 대한 구성 요소를 애플리케이션 컨텍스트에 등록하는 주석 프로세서를 추가합니다.

이 @IntegrationComponentScan애노테이션은 클래스 경로 스캔도 허용합니다. 이 애노테이션은 표준 Spring Framework 애노테이션과 유사한 역할을 @ComponentScan하지만, Spring Integration에 특화된 컴포넌트 및 애노테이션으로 제한됩니다. 따라서 표준 Spring Framework 컴포넌트 스캔 메커니즘으로는 접근할 수 없습니다. 자세한 내용은 @MessagingGatewayAnnotation을 참조하세요 .

애노테이션 은 빈을 @EnablePublisher등록 하고 속성 없이 제공되는 애노테이션 에 대한 PublisherAnnotationBeanPostProcessor를 구성합니다 . 애노테이션이 두 개 이상 있는 경우, 기본 채널에 대해 모두 동일한 값을 가져야 합니다. 자세한 내용은 애노테이션을 사용한 애노테이션 기반 구성을 참조하세요.default-publisher-channel@Publisherchannel@EnablePublisher@Publisher

이 @GlobalChannelInterceptor애노테이션은 글로벌 채널 인터셉션을 위해 Bean을 표시하기 위해 도입되었습니다 ChannelInterceptor. 이 애노테이션은 XML 요소와 유사합니다 ( 글로벌 채널 인터셉터 구성<int:channel-interceptor> 참조 ). 애노테이션은 클래스 수준( 스테레오타입 애노테이션 사용) 또는 클래스 내의 메서드 에 배치할 수 있습니다 . 두 경우 모두 Bean은 를 구현해야 합니다 .@GlobalChannelInterceptor@Component@Bean@ConfigurationChannelInterceptor

버전 5.1부터 글로벌 채널 인터셉터는 동적으로 등록된 채널(예: Java DSL을 사용할 때 beanFactory.initializeBean()또는 를 통해 초기화되는 빈)에 적용됩니다 IntegrationFlowContext. 이전에는 애플리케이션 컨텍스트가 새로 고쳐진 후 빈이 생성될 때 인터셉터가 적용되지 않았습니다.

이 @IntegrationConverter주석은 Converter, GenericConverter, 또는 ConverterFactory빈을 의 후보 변환기로 표시합니다 . 이 주석은 XML 요소 integrationConversionService와 유사합니다 ( 페이로드 유형 변환 참조). 클래스 수준( 스테레오타입 주석 사용) 또는 클래스 내의 메서드 에 주석을 추가할 수 있습니다 .<int:converter>@IntegrationConverter@Component@Bean@Configuration

메시징 주석에 대한 자세한 내용은 주석 지원을 참조하세요 .

프로그래밍 고려 사항
Spring Integration의 대부분의 클래스는 (별도로 명시되지 않는 한) 애플리케이션 컨텍스트에서는 빈으로, 그리고 싱글턴으로 선언되어야 합니다. 즉, 이러한 클래스의 인스턴스는 스레드로부터 안전하며, 수명 주기와 다른 구성 요소와의 연결은 Spring 종속성 주입 컨테이너에 의해 관리됩니다. 유틸리티 및 빌더 클래스( , JacksonJsonUtils, `MessageBuilder등 )는 Java 코드에서 직접 사용할 수 있습니다. 그러나 Java DSL 팩토리와 구현 결과는 여전히 애플리케이션 컨텍스트에 빈으로 등록해야 합니다. 많은 모듈에 존재하는 추상화는 스레드로부터 안전하지 않으며, 일반적으로 패턴 구현에 의해 생성되고 스레드로부터 안전한 패턴에서 사용됩니다. 예를 들어 와 와의 관계를 참조하세요 .ExpressionEvalMapIntegrationReactiveUtilsIntegrationComponentSpecSessionFactoryTemplateSftpRemoteFileTemplateDefaultSftpSessionFactory

가능하면 대상 로직에서 메시지를 처리할 때 일반 Java 객체(POJO)를 사용하고, 절대적으로 필요한 경우에만 코드에 프레임워크를 노출해야 합니다. 자세한 내용은 POJO 메서드 호출을 참조하세요.

클래스에 프레임워크를 노출하는 경우, 특히 애플리케이션 시작 시 고려해야 할 몇 가지 사항이 있습니다.

구성 요소가 이면 일반적으로 메서드 에서 ApplicationContextAware를 사용해서는 안 됩니다 . 대신 참조를 저장하고 컨텍스트 수명 주기 후반으로 미루세요.ApplicationContextsetApplicationContext()

구성 요소가 InitializingBean이거나 메서드를 사용하는 경우 @PostConstruct, 이러한 초기화 메서드에서 메시지를 전송하지 마세요. 이러한 메서드가 호출될 때 애플리케이션 컨텍스트는 아직 초기화되지 않았으므로 이러한 메시지 전송은 실패할 가능성이 높습니다. 시작 중에 메시지를 전송해야 하는 경우 을 구현 ApplicationListener하고 을 기다리세요 ContextRefreshedEvent. 또는 을 구현하고 SmartLifecycle빈을 후기 단계에 배치한 후 start()메서드에서 메시지를 전송하세요.

포장된(예: 음영 처리된) 병을 사용할 때의 고려 사항
Spring Integration은 Spring Framework의 메커니즘을 사용하여 SpringFactories여러 클래스를 로드함으로써 특정 기능을 부트스트랩합니다 IntegrationConfigurationInitializer. 여기에는 -corejar 파일뿐만 아니라 , -http를 포함한 특정 파일도 포함됩니다 -jmx. 이 프로세스에 대한 정보는 각 jar 파일의 파일에 저장됩니다 META-INF/spring.factories.

일부 개발자는 Apache Maven Shade 플러그인 과 같은 잘 알려진 도구를 사용하여 애플리케이션과 모든 종속성을 단일 jar 파일로 다시 패키징하는 것을 선호합니다 .

기본적으로, 셰이드 플러그인은 spring.factories셰이딩된 jar 파일을 생성할 때 파일을 병합하지 않습니다.

이외에도 spring.factories다른 META-INF파일( spring.handlers및 spring.schemas)이 XML 구성에 사용됩니다. 이러한 파일도 병합해야 합니다.

Spring Boot의 실행 가능 jar 메커니즘은 다른 방식을 취합니다. jar 파일을 중첩하여 각 spring.factories파일을 클래스 경로에 유지합니다. 따라서 Spring Boot 애플리케이션에서는 기본 실행 가능 jar 형식을 사용하면 더 이상 필요한 것이 없습니다.
Spring Boot를 사용하지 않더라도 Boot에서 제공하는 도구를 사용하여 위에 언급된 파일에 대한 변환기를 추가하여 shade 플러그인을 향상시킬 수 있습니다. 다음 예제는 플러그인을 구성하는 방법을 보여줍니다.

예제 1. pom.xml
...
    <plugins>
        <plugin>
            <groupId>org.apache.maven.plugins</groupId>
            <artifactId>maven-shade-plugin</artifactId>
            <configuration>
                <keepDependenciesWithProvidedScope>true</keepDependenciesWithProvidedScope>
                <createDependencyReducedPom>true</createDependencyReducedPom>
            </configuration>
            <dependencies>
                <dependency> 
                    <groupId>org.springframework.boot</groupId>
                    <artifactId>spring-boot-maven-plugin</artifactId>
                    <version>${spring.boot.version}</version>
                </dependency>
            </dependencies>
            <executions>
                <execution>
                    <phase>package</phase>
                    <goals>
                        <goal>shade</goal>
                    </goals>
                    <configuration>
                        <transformers> 
                            <transformer
                                implementation="org.apache.maven.plugins.shade.resource.AppendingTransformer">
                                <resource>META-INF/spring.handlers</resource>
                            </transformer>
                            <transformer
                                implementation="org.springframework.boot.maven.PropertiesMergingResourceTransformer">
                                <resource>META-INF/spring.factories</resource>
                            </transformer>
                            <transformer
                                implementation="org.apache.maven.plugins.shade.resource.AppendingTransformer">
                                <resource>META-INF/spring.schemas</resource>
                            </transformer>
                            <transformer
                                implementation="org.apache.maven.plugins.shade.resource.ServicesResourceTransformer" />
                        </transformers>
                    </configuration>
                </execution>
            </executions>
        </plugin>
    </plugins>
...
구체적으로,

spring-boot-maven-plugin종속성으로 추가합니다 .
변압기를 구성합니다.
속성을 추가하거나 ${spring.boot.version}명시적 버전을 사용할 수 있습니다.

프로그래밍 팁과 요령
이 섹션에서는 Spring Integration을 최대한 활용하는 몇 가지 방법을 설명합니다.

XML 스키마
XML 구성을 사용할 때 잘못된 스키마 유효성 검사 오류가 발생하지 않도록 Spring Tool Suite(STS), Spring IDE 플러그인이 포함된 Eclipse, IntelliJ IDEA와 같은 "Spring 지원" IDE를 사용해야 합니다. 이러한 IDE는 jar 파일 내의 파일을 사용하여 클래스 경로에서 올바른 XML 스키마를 확인합니다 . 플러그인과 함께 STS 또는 Eclipse를 사용하는 경우 프로젝트에서 META-INF/spring.schemas해당 기능을 활성화해야 합니다 .Spring Project Nature

특정 레거시 모듈(1.0 버전에 존재했던 모듈)에 대해 인터넷에 호스팅된 스키마는 호환성을 위해 1.0 버전으로 제공됩니다. IDE에서 이러한 스키마를 사용하는 경우 잘못된 오류가 발생할 가능성이 높습니다.

이러한 각 온라인 스키마에는 다음과 유사한 경고가 있습니다.

이 스키마는 Spring Integration Core 1.0 버전용입니다. 1.0.3 이하 버전을 사용하는 애플리케이션은 작동이 중단되므로 현재 스키마로 업데이트할 수 없습니다. 이후 버전에서는 "버전 관리되지 않은" 스키마가 클래스 경로에서 확인되어 jar 파일에서 가져옵니다. GitHub을 참조하세요.

github.com/spring-projects/spring-integration/tree/main/spring-integration-core/src/main/resources/org/springframework/integration/config

영향을 받는 모듈은 다음과 같습니다.

core ( spring-integration.xsd)

file

http

jms

mail

security

stream

ws

xml

Java 및 DSL 구성을 위한 클래스 이름 찾기
XML 구성 및 Spring Integration 네임스페이스 지원을 통해 XML 파서는 대상 Bean의 선언 및 연결 방식을 숨깁니다. Java 구성의 경우, 대상 최종 사용자 애플리케이션의 프레임워크 API를 이해하는 것이 중요합니다.

EIP 구현의 일등 시민은 Message, Channel, 입니다 (이 장 앞부분의 주요 구성 요소Endpoint 참조 ). 이들의 구현(계약)은 다음과 같습니다.

org.springframework.messaging.Message: 메시지 참조 ;

org.springframework.messaging.MessageChannel: 메시지 채널을 참조하세요 .

org.springframework.integration.endpoint.AbstractEndpoint: 폴러를 참조하세요 .

처음 두 가지는 구현, 구성 및 사용 방법을 이해하기에 충분히 간단합니다. 마지막 두 가지는 더 자세히 살펴볼 가치가 있습니다.

는 AbstractEndpointSpring 프레임워크 전반에서 다양한 컴포넌트 구현에 널리 사용됩니다. 주요 구현은 다음과 같습니다.

EventDrivenConsumerSubscribableChannel메시지를 수신하기 위해 a에 가입할 때 사용됩니다 .

PollingConsumer, .에서 메시지를 폴링할 때 사용됩니다 PollableChannel.

메시징 애노테이션이나 Java DSL을 사용하는 경우, 프레임워크가 적절한 애노테이션과 구현을 통해 자동으로 컴포넌트를 생성하므로 이러한 컴포넌트에 대해 걱정할 필요가 없습니다 . 컴포넌트를 수동으로 빌드하는 경우, 제공된 속성을 기반으로 생성할 대상 소비자 구현을 결정하는 데 도움이 되도록 BeanPostProcessor를 사용해야 합니다 .ConsumerEndpointFactoryBeanAbstractEndpointinputChannel

반면, ConsumerEndpointFactoryBean프레임워크의 다른 일급 시민에 대한 위임은 - 입니다 org.springframework.messaging.MessageHandler. 이 인터페이스 구현의 목표는 채널에서 엔드포인트가 사용하는 메시지를 처리하는 것입니다. Spring Integration의 모든 EIP 구성 요소 MessageHandler(예: AggregatingMessageHandler, MessageTransformingHandler, AbstractMessageSplitter등)는 구현입니다. 대상 프로토콜 아웃바운드 어댑터( FileWritingMessageHandler, HttpRequestExecutingMessageHandler, AbstractMqttMessageHandler등)도 MessageHandler구현입니다. Java 구성을 사용하여 Spring Integration 애플리케이션을 개발할 때는 Spring Integration 모듈을 검토하여 MessageHandler구성에 사용할 적절한 구현을 찾아야 합니다 @ServiceActivator. 예를 들어 XMPP 메시지( XMPP 지원 참조 )를 전송하려면 다음과 같이 구성해야 합니다.

@Bean
@ServiceActivator(inputChannel = "input")
public MessageHandler sendChatMessageHandler(XMPPConnection xmppConnection) {
    ChatMessageSendingMessageHandler handler = new ChatMessageSendingMessageHandler(xmppConnection);

    DefaultXmppHeaderMapper xmppHeaderMapper = new DefaultXmppHeaderMapper();
    xmppHeaderMapper.setRequestHeaderNames("*");
    handler.setHeaderMapper(xmppHeaderMapper);

    return handler;
}
구현 MessageHandler은 메시지 흐름의 아웃바운드 및 처리 부분을 나타냅니다.

인바운드 메시지 흐름 측면에는 폴링(polling)과 수신(listening) 동작으로 구분되는 자체 구성 요소가 있습니다. 수신(메시지 기반) 구성 요소는 간단하며 일반적으로 메시지를 생성할 준비가 되기 위해 하나의 대상 클래스 구현만 필요합니다. 수신 구성 요소는 단방향 MessageProducerSupport구현(예: AbstractMqttMessageDrivenChannelAdapter및 ImapIdleChannelAdapter)이거나 요청-응답 MessagingGatewaySupport구현(예: AmqpInboundGateway및 AbstractWebServiceInboundGateway)일 수 있습니다.

폴링 인바운드 엔드포인트는 리스너 API를 제공하지 않거나 그러한 동작을 목적으로 하지 않은 프로토콜을 위한 것이며, 여기에는 FTP와 같은 파일 기반 프로토콜, RDBMS 또는 NoSQL과 같은 데이터베이스 등이 포함됩니다.

이러한 인바운드 엔드포인트는 두 가지 구성 요소로 구성됩니다. 폴링 작업을 주기적으로 시작하는 폴러 구성과 대상 프로토콜에서 데이터를 읽고 다운스트림 통합 흐름에 대한 메시지를 생성하는 메시지 소스 클래스입니다. 폴러 구성의 첫 번째 클래스는 입니다 SourcePollingChannelAdapter. 이는 또 다른 AbstractEndpoint구현이지만, 특히 통합 흐름을 시작하기 위한 폴링에 적합합니다. 일반적으로 메시징 애노테이션이나 Java DSL을 사용하는 경우 이 클래스에 대해 신경 쓸 필요가 없습니다. 프레임워크는 구성 또는 Java DSL 빌더 사양을 기반으로 해당 클래스에 대한 빈을 생성합니다 @InboundChannelAdapter.

메시지 소스 구성 요소는 대상 애플리케이션 개발에 더욱 중요하며, 모두 해당 MessageSource인터페이스를 구현합니다(예: MongoDbMessageSource및 AbstractTwitterMessageSource). 이를 염두에 두고, JDBC를 사용하여 RDBMS 테이블에서 데이터를 읽기 위한 구성은 다음과 유사할 수 있습니다.

@Bean
@InboundChannelAdapter(value = "fooChannel", poller = @Poller(fixedDelay="5000"))
public MessageSource<?> storedProc(DataSource dataSource) {
    return new JdbcPollingChannelAdapter(dataSource, "SELECT * FROM foo where status = 0");
}
대상 프로토콜에 필요한 모든 인바운드 및 아웃바운드 클래스는 특정 Spring Integration 모듈(대부분의 경우 해당 패키지)에서 찾을 수 있습니다. 예를 들어, spring-integration-websocket어댑터는 다음과 같습니다.

o.s.i.websocket.inbound.WebSocketInboundChannelAdapter: MessageProducerSupport소켓에서 프레임을 수신하고 채널에 메시지를 생성하는 구현입니다.

o.s.i.websocket.outbound.WebSocketOutboundMessageHandlerAbstractMessageHandler: 들어오는 메시지를 적절한 프레임으로 변환하고 웹소켓을 통해 전송하는 단방향 구현입니다.

Spring Integration XML 구성에 익숙하다면 버전 4.3부터 어댑터나 게이트웨이에 대한 Bean을 선언하는 데 사용되는 대상 클래스에 대한 정보를 XSD 요소 정의에 제공합니다(다음 예제 참조).

<xsd:element name="outbound-async-gateway">
    <xsd:annotation>
		<xsd:documentation>
Configures a Consumer Endpoint for the 'o.s.i.amqp.outbound.AsyncAmqpOutboundGateway'
that will publish an AMQP Message to the provided Exchange and expect a reply Message.
The sending thread returns immediately; the reply is sent asynchronously; uses 'AsyncRabbitTemplate.sendAndReceive()'.
       </xsd:documentation>
	</xsd:annotation>
POJO 메서드 호출
프로그래밍 고려사항 에서 설명한 대로 다음 예와 같이 POJO 프로그래밍 스타일을 사용하는 것이 좋습니다.

@ServiceActivator
public String myService(String payload) { ... }
이 경우, 프레임워크는 String페이로드를 추출하고, 메서드를 호출하고, 결과를 메시지로 래핑하여 흐름의 다음 구성 요소로 전송합니다(원래 헤더는 새 메시지에 복사됩니다). 실제로 XML 구성을 사용하는 경우 @ServiceActivator다음 쌍의 예시에서 볼 수 있듯이 애노테이션이 필요하지 않습니다.

<int:service-activator ... ref="myPojo" method="myService" />
public String myService(String payload) { ... }
method클래스의 공개 메서드에 모호함이 없는 한 속성을 생략할 수 있습니다 .

다음 예제와 같이 POJO 메서드에서 헤더 정보를 얻을 수도 있습니다.

@ServiceActivator
public String myService(@Payload String payload, @Header("foo") String fooHeader) { ... }
다음 예제와 같이 메시지의 속성을 역참조할 수도 있습니다.

@ServiceActivator
public String myService(@Payload("payload.foo") String foo, @Header("bar.baz") String barbaz) { ... }
다양한 POJO 메서드 호출이 가능하기 때문에 5.0 이전 버전에서는 SpEL(Spring Expression Language)을 사용하여 POJO 메서드를 호출했습니다. SpEL(인터프리터 방식 포함)은 일반적으로 메서드에서 수행되는 실제 작업과 비교했을 때 이러한 작업에 "충분히 빠릅니다". 그러나 5.0 버전부터는 org.springframework.messaging.handler.invocation.InvocableHandlerMethod가능한 경우 기본적으로 SpEL이 사용됩니다. 이 기법은 일반적으로 인터프리터 방식 SpEL보다 실행 속도가 빠르며 다른 Spring 메시징 프로젝트와 일관성을 유지합니다. SpEL은 InvocableHandlerMethodSpring MVC에서 컨트롤러 메서드를 호출하는 데 사용되는 기법과 유사합니다. SpEL을 사용할 때에도 여전히 항상 호출되는 특정 메서드가 있습니다. 앞서 설명한 것처럼 참조가 해제된 속성을 가진 주석이 달린 매개변수가 그 예입니다. 이는 SpEL이 속성 경로를 탐색할 수 있기 때문입니다.

인스턴스 에서 작동하지 않는, 아직 고려하지 않은 다른 코너 케이스가 있을 수 있습니다 InvocableHandlerMethod. 이러한 이유로 이러한 경우에는 자동으로 SpEL을 사용합니다.

UseSpelInvoker원하는 경우 다음 예제와 같이 주석 과 함께 SpEL을 항상 사용하도록 POJO 메서드를 설정할 수도 있습니다 .

@UseSpelInvoker(compilerMode = "IMMEDIATE")
public void bar(String bar) { ... }
이 compilerMode속성을 생략하면 spring.expression.compiler.mode시스템 속성에 따라 컴파일러 모드가 결정됩니다. 컴파일된 SpEL에 대한 자세한 내용은 SpEL 컴파일을 참조하세요.


---

Spring Integration Framework 개요

Spring Integration은 잘 알려진 **Enterprise Integration Patterns(EIP)**를 지원하도록 Spring 프로그래밍 모델을 확장합니다. 이를 통해 Spring 기반 애플리케이션 내에서 경량 메시징을 가능하게 하고, 선언적 어댑터를 통해 외부 시스템과 통합할 수 있습니다. 이러한 어댑터는 Spring의 원격 호출, 메시징, 스케줄링 지원 위에 높은 수준의 추상화를 제공합니다.

Spring Integration의 주요 목표는 복잡한 엔터프라이즈 통합 솔루션을 간단한 모델로 구축하면서, 유지보수 가능하고 테스트 가능한 코드를 작성하기 위해 필요한 관심사의 분리를 유지하는 것입니다.

Spring Integration 개요

이 장에서는 Spring Integration의 핵심 개념과 구성요소를 고수준에서 소개합니다. 또한 Spring Integration을 최대한 활용하기 위한 프로그래밍 팁도 포함되어 있습니다.

배경

Spring Framework의 핵심 주제 중 하나는 **Inversion of Control(IoC, 제어 역전)**입니다. 이는 프레임워크가 컨텍스트 내에서 관리되는 구성 요소를 대신하여 책임을 처리한다는 의미입니다. 구성 요소는 이러한 책임에서 해방되므로 단순해집니다. 예를 들어, 의존성 주입은 구성 요소가 자신의 의존성을 찾거나 생성하는 책임을 덜어줍니다. 마찬가지로 AOP(Aspect-Oriented Programming)는 공통 관심사를 재사용 가능한 모듈로 분리함으로써 비즈니스 구성 요소를 단순화합니다. 결과적으로 테스트, 이해, 유지보수, 확장이 쉬운 시스템을 제공합니다.

Spring 프레임워크와 포트폴리오는 엔터프라이즈 애플리케이션 개발을 위한 일관된 프로그래밍 모델을 제공합니다. 개발자는 인터페이스 기반 프로그래밍, 상속보다 구성(composition) 선호와 같은 검증된 모범 사례의 장점을 누릴 수 있습니다. Spring의 추상화와 강력한 지원 라이브러리는 생산성을 높이는 동시에 테스트 용이성과 이식성을 향상시킵니다.

Spring Integration도 이러한 목표와 원칙을 바탕으로 설계되었습니다. Spring 프로그래밍 모델을 메시징 영역으로 확장하고, 기존 Spring 엔터프라이즈 통합 지원 위에 더 높은 수준의 추상화를 제공합니다. 메시지 기반 아키텍처를 지원하며, IoC는 실행 시점(runtime) 결정(예: 언제 특정 비즈니스 로직을 실행하고 어디로 응답을 보낼지)에 적용됩니다. 메시지 라우팅 및 변환을 지원하여, 다양한 전송 방식과 데이터 형식을 통합하더라도 테스트 가능성이 유지됩니다. 즉, 메시징 및 통합 관심사는 프레임워크가 처리하며, 비즈니스 구성 요소는 인프라로부터 격리됩니다.

Spring Integration은 다양한 구성 옵션을 제공합니다:

어노테이션

XML(네임스페이스 지원)

XML(일반 “bean” 요소)

직접 API 사용

이 API는 전략 인터페이스와 비침습적 위임 어댑터를 기반으로 합니다. Spring Integration의 설계는 Spring의 공통 패턴과 EIP(EIP: Enterprise Integration Patterns, Gregor Hohpe & Bobby Woolf, 2004)에서 설명된 패턴 간 강한 유사성을 인식한 데서 영감을 받았습니다.

목표 및 원칙

목표

복잡한 엔터프라이즈 통합 솔루션을 구현하기 위한 간단한 모델 제공

Spring 기반 애플리케이션 내에서 비동기 메시지 기반 동작 촉진

기존 Spring 사용자에게 직관적이고 점진적인 도입 제공

원칙

구성 요소는 느슨하게 결합되어야 함 (모듈화 및 테스트 용이성)

비즈니스 로직과 통합 로직 간의 관심사 분리 유지

확장 지점은 추상적이어야 하며, 재사용성과 이식성 향상

주요 구성 요소
메시지(Message)

메시지는 Java 객체와 이를 처리하는 메타데이터를 포함하는 일반 래퍼입니다.

구성: payload + headers

payload: 모든 타입 가능

headers: ID, 타임스탬프, correlation ID, return address 등 포함

headers는 전송과 수신 시 값 전달에도 사용 가능

메시지 채널(Message Channel)

메시지 채널은 **파이프-앤-필터 구조의 “파이프”**를 나타냅니다.

프로듀서 → 채널 → 컨슈머

포인트-투-포인트(point-to-point) 또는 퍼블리시-서브스크라이브(publish-subscribe) 방식 지원

폴러블 채널(pollable channels): 메시지 버퍼링 가능

서브스크라이버 채널(subscribable channels): 메시지 주도(message-driven)

메시지 엔드포인트(Message Endpoint)

메시지 엔드포인트는 애플리케이션 코드와 메시징 인프라를 연결하는 “필터” 역할을 합니다.

Message Transformer: 메시지 payload/헤더 변환

Message Filter: 조건에 따라 메시지 전달 여부 결정

Message Router: 메시지를 어느 채널로 보낼지 결정

Splitter: 하나의 메시지를 여러 메시지로 분할

Aggregator: 여러 메시지를 하나로 합침

Service Activator: 서비스 객체를 메시징 시스템에 연결

Channel Adapter: 메시지 채널과 외부 시스템 연결

엔드포인트 빈 이름 규칙

Consumer: 엔드포인트 ID 또는 메서드 기반 생성

Handler: .handler 접미사 사용

예: @EndpointId("someService") → Consumer: someService, Handler: someService.handler

구성 및 @EnableIntegration

XML 네임스페이스를 사용하면 구성 요소 선언 시 자동으로 Bean 생성

@EnableIntegration: Java 기반 구성만 사용할 때 Spring Integration 인프라 등록

@IntegrationComponentScan: 컴포넌트 스캔

@GlobalChannelInterceptor: 글로벌 채널 인터셉터

@IntegrationConverter: 컨버터 등록

프로그래밍 고려사항

Spring Integration 클래스는 싱글톤 Bean으로 선언

POJO를 사용하여 메시지 핸들링

ApplicationContextAware, InitializingBean, @PostConstruct에서 메시지 전송 금지

메시지 전송이 필요하면 ApplicationListener나 SmartLifecycle 사용

패키지된 Jar 사용 시 고려사항

SpringFactories 메커니즘으로 초기화

Shaded Jar 사용 시 spring.factories, spring.handlers, spring.schemas 병합 필요

Spring Boot의 실행 가능 jar는 Jar를 중첩하여 별도 병합 불필요

프로그래밍 팁

XML 구성 시 Spring-aware IDE 사용 (STS, Eclipse, IntelliJ)

EIP 구현 주요 클래스: Message, MessageChannel, Endpoint(AbstractEndpoint)

메시지 핸들러(MessageHandler) 구현체 사용: AggregatingMessageHandler, MessageTransformingHandler 등

POJO 기반 메서드 호출 권장

SpEL 사용 가능하나, 5.0 이상은 InvocableHandlerMethod 기본 사용